package com.example.id_card_reader

import androidx.annotation.NonNull
import android.hardware.usb.*

import android.app.PendingIntent

import android.content.BroadcastReceiver
import android.content.Context
import android.content.Intent
import android.content.IntentFilter

import io.flutter.embedding.engine.plugins.FlutterPlugin
import io.flutter.plugin.common.MethodCall
import io.flutter.plugin.common.MethodChannel
import io.flutter.plugin.common.EventChannel
import io.flutter.plugin.common.MethodChannel.MethodCallHandler
import io.flutter.plugin.common.MethodChannel.Result

import com.acs.smartcard.Features;
import com.acs.smartcard.PinModify;
import com.acs.smartcard.PinProperties;
import com.acs.smartcard.PinVerify;
import com.acs.smartcard.ReadKeyOption;
import com.acs.smartcard.Reader;
import com.acs.smartcard.Reader.OnStateChangeListener;
import com.acs.smartcard.TlvProperties;

private const val ACTION_USB_PERMISSION = "com.example.id_card_reader.USB_PERMISSION"

private fun pendingPermissionIntent(context: Context) = PendingIntent.getBroadcast(context, 0, Intent(ACTION_USB_PERMISSION), 0)



/** IdCardReaderPlugin */
class IdCardReaderPlugin: FlutterPlugin, MethodCallHandler {
  /// The MethodChannel that will the communication between Flutter and native Android
  ///
  /// This local reference serves to register the plugin with the Flutter Engine and unregister it
  /// when the Flutter Engine is detached from the Activity
  private lateinit var channel : MethodChannel
  // private var eChannel: EventChannel? = null
  private var randomNumberEventChannel: EventChannel? = null
  private var eventSink: EventChannel.EventSink? = null

  private var applicationContext: Context? = null
  private var usbManager: UsbManager? = null

  // acs
  // private var mReader: Reader? = null


  override fun onAttachedToEngine(@NonNull flutterPluginBinding: FlutterPlugin.FlutterPluginBinding) {
    channel = MethodChannel(flutterPluginBinding.binaryMessenger, "id_card_reader")
    channel.setMethodCallHandler(this)
    applicationContext = flutterPluginBinding.applicationContext
    usbManager = applicationContext?.getSystemService(Context.USB_SERVICE) as UsbManager
    // mReader = Reader(usbManager);

    val randomNumberEventChannel = EventChannel(flutterPluginBinding.binaryMessenger, "random_number_channel")
    randomNumberEventChannel.setStreamHandler(RandomNumberStreamHandler())

    val deviceEventChannel = EventChannel(flutterPluginBinding.binaryMessenger, "device_stream_channel")
    deviceEventChannel.setStreamHandler(DeviceStreamHandler())
  }

  override fun onDetachedFromEngine(@NonNull binding: FlutterPlugin.FlutterPluginBinding) {
    channel.setMethodCallHandler(null)
    usbManager = null
    applicationContext = null
  }

  private var usbDevice: UsbDevice? = null
  private var usbDeviceConnection: UsbDeviceConnection? = null

  private val receiver = object : BroadcastReceiver() {
    override fun onReceive(context: Context, intent: Intent) {
      context.unregisterReceiver(this)
      val device = intent.getParcelableExtra<UsbDevice>(UsbManager.EXTRA_DEVICE)
      val granted = intent.getBooleanExtra(UsbManager.EXTRA_PERMISSION_GRANTED, false)
      if (!granted) {
        println("Permission denied: ${device?.deviceName}")
      }
    }
  }

  override fun onMethodCall(@NonNull call: MethodCall, @NonNull result: Result) {
    when (call.method) {
    "getPlatformVersion" -> {
      result.success("Android ${android.os.Build.VERSION.RELEASE}")
    } 
    "getDeviceList" -> {
      val manager = usbManager ?: return result.error("IllegalState", "usbManager null", null)
      val usbDeviceList = manager.deviceList.entries.map {
        mapOf(
                "identifier" to it.key,
                "vendorId" to it.value.vendorId,
                "productId" to it.value.productId,
                "configurationCount" to it.value.configurationCount
        )
      }
      result.success(usbDeviceList)
    }
    "test1" -> {
      val manager = usbManager ?: return result.error("IllegalState", "usbManager null", null)
      val usbDeviceList = manager.deviceList.entries
      result.success(usbDeviceList)
    }
    "requestPermission" -> {
      val context = applicationContext ?: return result.error("IllegalState", "applicationContext null", null)
      val manager = usbManager ?: return result.error("IllegalState", "usbManager null", null)
      val identifier = call.argument<String>("identifier")
      val device = manager.deviceList[identifier]
      if (!manager.hasPermission(device)) {
        context.registerReceiver(receiver, IntentFilter(ACTION_USB_PERMISSION))
        manager.requestPermission(device, pendingPermissionIntent(context))
      }
      result.success(null)
    }

    // "getData" -> {
    //   // val identifier = call.argument<String>("identifier")
    //   val context = applicationContext ?: return result.error("IllegalState", "applicationContext null", null)
    //   val manager = usbManager ?: return result.error("IllegalState", "usbManager null", null)
    //   val reader = mReader ?: return result.error("IllegalState", "mReader null", null)
    //   val device = manager.deviceList.first
    //   if (!manager.hasPermission(device)) {
    //     context.registerReceiver(receiver, IntentFilter(ACTION_USB_PERMISSION))
    //     manager.requestPermission(device, pendingPermissionIntent(context))
    //   }
    //   val xa = reader.open(manager[0])
    //   result.success(null)
    // }
    
      
    else -> result.notImplemented()
    }
  }

  //  private fun getData() {
  //   val batteryLevel: Int
  //   if (VERSION.SDK_INT >= VERSION_CODES.LOLLIPOP) {
  //     val batteryManager = getSystemService(Context.BATTERY_SERVICE) as BatteryManager
  //     batteryLevel = batteryManager.getIntProperty(BatteryManager.BATTERY_PROPERTY_CAPACITY)
  //   } else {
  //     val intent = ContextWrapper(applicationContext).registerReceiver(null, IntentFilter(Intent.ACTION_BATTERY_CHANGED))
  //     batteryLevel = intent!!.getIntExtra(BatteryManager.EXTRA_LEVEL, -1) * 100 / intent.getIntExtra(BatteryManager.EXTRA_SCALE, -1)
  //   }

  //   return batteryLevel
  // }
 
}
